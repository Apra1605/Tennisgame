<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Tennis Game</title>
<style>
body { margin:0; overflow:hidden; background:#1c2b34; }
#scoreboard {
  position:absolute;
  top:14px;
  right:14px;
  left:auto;
  transform:none;
  width:min(430px, 48vw);
  background:linear-gradient(180deg, rgba(17,25,33,0.9), rgba(17,25,33,0.74));
  border:1px solid rgba(255,255,255,0.18);
  border-radius:12px;
  color:#f4f7fa;
  font-family:Arial, sans-serif;
  backdrop-filter: blur(3px);
  box-shadow:0 10px 26px rgba(0,0,0,0.28);
  z-index:20;
}
#scoreGrid {
  display:grid;
  grid-template-columns: 1.2fr 1fr 1fr 1fr;
  align-items:center;
  gap:6px;
  padding:8px 10px;
  font-size:13px;
}
.sHead {
  font-size:10px;
  letter-spacing:0.12em;
  opacity:0.7;
  text-transform:uppercase;
}
.sCell {
  text-align:center;
  font-weight:700;
  font-size:17px;
}
.sName {
  text-align:left;
  font-weight:700;
  font-size:13px;
}
#scoreStatus {
  text-align:center;
  font-weight:700;
  font-size:10px;
  letter-spacing:0.08em;
  text-transform:uppercase;
  opacity:0.9;
  border-top:1px solid rgba(255,255,255,0.12);
  padding:6px 0 7px;
}
#powerHud {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 320px;
  opacity: 0;
  transition: opacity 0.12s linear;
  pointer-events: none;
}
#powerBar {
  width: 100%;
  height: 14px;
  border-radius: 999px;
  border: 2px solid rgba(255,255,255,0.9);
  background: rgba(12,19,26,0.45);
  overflow: hidden;
}
#powerFill {
  height: 100%;
  width: 0%;
  border-radius: 999px;
  background: linear-gradient(90deg, #39d98a 0%, #f4cc2a 58%, #ff6a3d 100%);
  transition: width 0.05s linear;
}
#rallyCallout {
  position: absolute;
  top: 58px;
  left: 50%;
  transform: translateX(-50%);
  min-width: 240px;
  max-width: min(74vw, 560px);
  text-align: center;
  padding: 8px 12px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(12, 18, 23, 0.82);
  color: #f6f7fb;
  font-family: Arial, sans-serif;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  opacity: 0;
  transition: opacity 0.12s linear;
  pointer-events: none;
  z-index: 21;
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/+esm"
  }
}
</script>
</head>
<body>
<div id="scoreboard">
  <div id="scoreGrid">
    <div class="sHead">Player</div>
    <div class="sHead">Sets</div>
    <div class="sHead">Games</div>
    <div class="sHead">Points</div>

    <div class="sName" id="nameYou">You</div>
    <div class="sCell" id="setsYou">0</div>
    <div class="sCell" id="gamesYou">0</div>
    <div class="sCell" id="pointsYou">0</div>

    <div class="sName" id="nameAi">Vega AI</div>
    <div class="sCell" id="setsAi">0</div>
    <div class="sCell" id="gamesAi">0</div>
    <div class="sCell" id="pointsAi">0</div>
  </div>
  <div id="scoreStatus">Match In Progress</div>
</div>
<div id="powerHud">
  <div id="powerBar"><div id="powerFill"></div></div>
</div>
<div id="rallyCallout"></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.182.0/+esm";

//////////////////////////////////////////////////
// BASIC SETUP
//////////////////////////////////////////////////

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xc8c3b8);
scene.fog = new THREE.Fog(0xc8c3b8, 56, 195);

const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.1,1000);
camera.position.set(0,20,-48);
camera.lookAt(0,3.5,8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.050;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Tennis scoreboard state (3 games = 1 set, first to 2 sets wins).
const PLAYER_NAME = "Player";
const AI_NAME = "Vega AI";
const scoreEls = {
  nameYou: document.getElementById("nameYou"),
  nameAi: document.getElementById("nameAi"),
  setsYou: document.getElementById("setsYou"),
  setsAi: document.getElementById("setsAi"),
  gamesYou: document.getElementById("gamesYou"),
  gamesAi: document.getElementById("gamesAi"),
  pointsYou: document.getElementById("pointsYou"),
  pointsAi: document.getElementById("pointsAi"),
  status: document.getElementById("scoreStatus")
};
scoreEls.nameYou.textContent = PLAYER_NAME;
scoreEls.nameAi.textContent = AI_NAME;

const tennisScore = {
  pointsYou: 0,
  pointsAi: 0,
  gamesYou: 0,
  gamesAi: 0,
  setsYou: 0,
  setsAi: 0,
  matchWinner: null
};

function pointText(playerPoints, opponentPoints){
  const map = ["0", "15", "30", "40"];
  if(playerPoints >= 3 && opponentPoints >= 3){
    if(playerPoints === opponentPoints) return "40";
    return playerPoints > opponentPoints ? "AD" : "40";
  }
  return map[Math.min(3, playerPoints)];
}

function updateScoreboard(){
  scoreEls.setsYou.textContent = tennisScore.setsYou;
  scoreEls.setsAi.textContent = tennisScore.setsAi;
  scoreEls.gamesYou.textContent = tennisScore.gamesYou;
  scoreEls.gamesAi.textContent = tennisScore.gamesAi;
  scoreEls.pointsYou.textContent = pointText(tennisScore.pointsYou, tennisScore.pointsAi);
  scoreEls.pointsAi.textContent = pointText(tennisScore.pointsAi, tennisScore.pointsYou);
  scoreEls.status.textContent = tennisScore.matchWinner
    ? `${tennisScore.matchWinner} wins the match`
    : "Match In Progress";
}

function awardPoint(side){
  if(tennisScore.matchWinner) return;

  if(side === "you") tennisScore.pointsYou += 1;
  else tennisScore.pointsAi += 1;

  const p = side === "you" ? tennisScore.pointsYou : tennisScore.pointsAi;
  const o = side === "you" ? tennisScore.pointsAi : tennisScore.pointsYou;

  if(p >= 4 && p - o >= 2){
    // Game won
    if(side === "you") tennisScore.gamesYou += 1;
    else tennisScore.gamesAi += 1;
    tennisScore.pointsYou = 0;
    tennisScore.pointsAi = 0;

    // Set won (first to 3 games)
    if(tennisScore.gamesYou >= 3 || tennisScore.gamesAi >= 3){
      if(tennisScore.gamesYou > tennisScore.gamesAi) tennisScore.setsYou += 1;
      else tennisScore.setsAi += 1;
      tennisScore.gamesYou = 0;
      tennisScore.gamesAi = 0;
    }

    // Match won (first to 2 sets)
    if(tennisScore.setsYou >= 2) tennisScore.matchWinner = PLAYER_NAME;
    if(tennisScore.setsAi >= 2) tennisScore.matchWinner = AI_NAME;
  }

  updateScoreboard();
}

updateScoreboard();

// Background music
const bgMusic = new Audio("./Gameaudio.m4a");
bgMusic.loop = true;
bgMusic.volume = 0.15;

let musicStarted = false;
function startMusic(){
 if(musicStarted) return;
 bgMusic.play().then(()=>{
  musicStarted = true;
  window.removeEventListener("pointerdown", startMusic);
  window.removeEventListener("keydown", startMusic);
  window.removeEventListener("touchstart", startMusic);
 }).catch(()=>{});
}

// Try immediate playback and fall back to first user interaction.
startMusic();
window.addEventListener("pointerdown", startMusic, { passive: true });
window.addEventListener("keydown", startMusic);
window.addEventListener("touchstart", startMusic, { passive: true });

const hemi = new THREE.HemisphereLight(0xf0e8dc, 0x625f55, 0.58);
scene.add(hemi);
scene.add(new THREE.AmbientLight(0xffffff,.2));
const sun = new THREE.DirectionalLight(0xffefdb,1.55);
sun.position.set(26,34,-8);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left = -28;
sun.shadow.camera.right = 28;
sun.shadow.camera.top = 28;
sun.shadow.camera.bottom = -28;
sun.shadow.camera.near = 2;
sun.shadow.camera.far = 90;
sun.shadow.bias = -0.00008;
scene.add(sun);

const rim = new THREE.DirectionalLight(0xffdfbf, 0.22);
rim.position.set(-24, 12, -26);
scene.add(rim);

const bounce = new THREE.PointLight(0xfff0d8, 0.3, 220, 2);
bounce.position.set(0, 12, 95);
scene.add(bounce);

const groundShadowCatcher = new THREE.Mesh(
  new THREE.PlaneGeometry(180,180),
  new THREE.ShadowMaterial({opacity:0.18})
);
groundShadowCatcher.rotation.x = -Math.PI * 0.5;
groundShadowCatcher.position.y = -0.249;
groundShadowCatcher.receiveShadow = true;
scene.add(groundShadowCatcher);

function createCityBackdrop(){
  const g = new THREE.Group();

  // Sky dome gradient (inside sphere)
  const skyGeo = new THREE.SphereGeometry(340, 40, 24);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    depthWrite: false,
    uniforms: {
      topColor: { value: new THREE.Color(0xc4b9aa) },
      midColor: { value: new THREE.Color(0xd7ccc0) },
      bottomColor: { value: new THREE.Color(0xe7dfd4) }
    },
    vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 midColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float h = normalize(vWorldPosition).y * 0.5 + 0.5;
        vec3 colA = mix(bottomColor, midColor, smoothstep(0.0, 0.55, h));
        vec3 colB = mix(midColor, topColor, smoothstep(0.45, 1.0, h));
        vec3 finalCol = mix(colA, colB, smoothstep(0.35, 1.0, h));
        gl_FragColor = vec4(finalCol, 1.0);
      }
    `
  });
  g.add(new THREE.Mesh(skyGeo, skyMat));

  // Distant city ring
  const cityGroup = new THREE.Group();
  const cityMatNear = new THREE.MeshStandardMaterial({color:0x3a4d5f, roughness:0.9, metalness:0.05});
  const cityMatFar = new THREE.MeshStandardMaterial({color:0x4d6377, roughness:0.94, metalness:0.03});
  const rng = (a,b)=> a + Math.random() * (b-a);

  function addCityBand(zBase, depth, count, spreadX, mat){
    for(let i=0;i<count;i++){
      const w = rng(2.2, 6.5);
      const h = rng(9, 28);
      const d = rng(2.2, 6.2);
      const x = rng(-spreadX, spreadX);
      const z = zBase + rng(-depth, depth);
      const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
      b.position.set(x, h * 0.5 - 0.15, z);
      b.receiveShadow = false;
      b.castShadow = false;
      cityGroup.add(b);
    }
  }

  addCityBand(120, 10, 70, 160, cityMatFar);
  addCityBand(-120, 10, 70, 160, cityMatFar);
  addCityBand(95, 8, 55, 130, cityMatNear);
  addCityBand(-95, 8, 55, 130, cityMatNear);

  // Side skylines
  for(let i=0;i<46;i++){
    const h = rng(8, 24);
    const w = rng(2, 5.2);
    const d = rng(2, 4.8);
    const z = rng(-120, 120);
    const left = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), cityMatNear);
    const right = left.clone();
    left.position.set(-125 + rng(-8,6), h * 0.5 - 0.2, z);
    right.position.set(125 + rng(-6,8), h * 0.5 - 0.2, z);
    cityGroup.add(left, right);
  }

  g.add(cityGroup);

  // Sun glow disk
  const sunGlow = new THREE.Mesh(
    new THREE.CircleGeometry(16, 40),
    new THREE.MeshBasicMaterial({color:0xffe7c1, transparent:true, opacity:0.2, depthWrite:false})
  );
  sunGlow.position.set(38, 46, -130);
  sunGlow.lookAt(0, 12, 0);
  g.add(sunGlow);

  // Horizon haze
  const haze = new THREE.Mesh(
    new THREE.PlaneGeometry(420, 90),
    new THREE.MeshBasicMaterial({color:0xbecad4, transparent:true, opacity:0.25, depthWrite:false})
  );
  haze.position.set(0, 22, 145);
  g.add(haze);

  return g;
}

scene.add(createCityBackdrop());

//////////////////////////////////////////////////
// COURT
//////////////////////////////////////////////////

const COURT_HALF_W = 15.0;
const BASELINE = 25;
const SERVICE = 13.5;
const SINGLES_HALF_W = 10.125;
const RUNOFF_HALF_W = 22;
const RUNOFF_HALF_L = 34;

function createCourtTexture(baseHex, speckHex, lineHex){
  const size = 256;
  const c = document.createElement("canvas");
  c.width = size;
  c.height = size;
  const ctx = c.getContext("2d");

  ctx.fillStyle = `#${baseHex.toString(16).padStart(6, "0")}`;
  ctx.fillRect(0, 0, size, size);

  for(let i = 0; i < 2500; i++){
    const x = Math.random() * size;
    const y = Math.random() * size;
    const a = 0.03 + Math.random() * 0.06;
    ctx.fillStyle = `rgba(${(speckHex >> 16) & 255}, ${(speckHex >> 8) & 255}, ${speckHex & 255}, ${a.toFixed(3)})`;
    ctx.fillRect(x, y, 1 + Math.random() * 2, 1 + Math.random() * 2);
  }

  for(let i = 0; i < 220; i++){
    const y = (i / 220) * size;
    ctx.fillStyle = `rgba(${(lineHex >> 16) & 255}, ${(lineHex >> 8) & 255}, ${lineHex & 255}, 0.015)`;
    ctx.fillRect(0, y, size, 1);
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = THREE.RepeatWrapping;
  tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(9, 16);
  tex.anisotropy = 8;
  return tex;
}

const inCourtTex = createCourtTexture(0x5f7e74, 0x2f3f3a, 0xb9c7c3);
const runoffTex = createCourtTexture(0x4f5f63, 0x2f373b, 0xa7b0b4);

const court = new THREE.Mesh(
  new THREE.BoxGeometry(COURT_HALF_W * 2, .5, BASELINE * 2),
  new THREE.MeshStandardMaterial({
    color:0xffffff,
    map: inCourtTex,
    roughness:0.83,
    metalness:0.01
  })
);
court.position.y=-.25;
court.receiveShadow = true;
scene.add(court);

// Neutral hard-court run-off area
const runoff = new THREE.Mesh(
  new THREE.BoxGeometry(RUNOFF_HALF_W * 2, 0.44, RUNOFF_HALF_L * 2),
  new THREE.MeshStandardMaterial({
    color: 0xffffff,
    map: runoffTex,
    roughness: 0.86,
    metalness: 0.02
  })
);
runoff.position.y = -0.255;
runoff.receiveShadow = true;
scene.add(runoff);

// Surrounding terrain
const outerGround = new THREE.Mesh(
  new THREE.PlaneGeometry(420, 420),
  new THREE.MeshStandardMaterial({color:0x8a8578, roughness:0.95, metalness:0.01})
);
outerGround.rotation.x = -Math.PI * 0.5;
outerGround.position.y = -0.27;
outerGround.receiveShadow = true;
scene.add(outerGround);

function createStadium(){
  const g = new THREE.Group();
  const standMat = new THREE.MeshStandardMaterial({color:0xa3adb8, roughness:0.86, metalness:0.08});
  const wallMat = new THREE.MeshStandardMaterial({color:0x2a4156, roughness:0.82, metalness:0.06});
  const seatMat = new THREE.MeshStandardMaterial({color:0x35516a, roughness:0.88, metalness:0.03});

  // Perimeter walls
  const sideWallL = new THREE.Mesh(new THREE.BoxGeometry(1.2, 4.5, 78), wallMat);
  const sideWallR = sideWallL.clone();
  sideWallL.position.set(-24, 2.25, 0);
  sideWallR.position.set(24, 2.25, 0);
  sideWallL.receiveShadow = true; sideWallR.receiveShadow = true;
  sideWallL.castShadow = true; sideWallR.castShadow = true;
  g.add(sideWallL, sideWallR);

  const backWallA = new THREE.Mesh(new THREE.BoxGeometry(50, 4.5, 1.2), wallMat);
  const backWallB = backWallA.clone();
  backWallA.position.set(0, 2.25, -38);
  backWallB.position.set(0, 2.25, 38);
  backWallA.receiveShadow = true; backWallB.receiveShadow = true;
  backWallA.castShadow = true; backWallB.castShadow = true;
  g.add(backWallA, backWallB);

  // Tiered stands around the court
  const tiers = [
    {w: 11, h: 1.2, z: 66, y: 0.6, x: 31},
    {w: 9.5, h: 1.2, z: 60, y: 1.8, x: 36},
    {w: 8, h: 1.2, z: 54, y: 3.0, x: 40.5}
  ];
  for(const t of tiers){
    const left = new THREE.Mesh(new THREE.BoxGeometry(t.w, t.h, t.z), standMat);
    const right = left.clone();
    left.position.set(-t.x, t.y, 0);
    right.position.set(t.x, t.y, 0);
    left.castShadow = true; right.castShadow = true;
    left.receiveShadow = true; right.receiveShadow = true;
    g.add(left, right);
  }

  const endTiers = [
    {w: 46, h: 1.2, z: 10, y: 0.6, x: 0, zPos: -47},
    {w: 40, h: 1.2, z: 8.5, y: 1.8, x: 0, zPos: -52},
    {w: 34, h: 1.2, z: 7, y: 3.0, x: 0, zPos: -56.5},
    {w: 46, h: 1.2, z: 10, y: 0.6, x: 0, zPos: 47},
    {w: 40, h: 1.2, z: 8.5, y: 1.8, x: 0, zPos: 52},
    {w: 34, h: 1.2, z: 7, y: 3.0, x: 0, zPos: 56.5}
  ];
  for(const t of endTiers){
    const block = new THREE.Mesh(new THREE.BoxGeometry(t.w, t.h, t.z), seatMat);
    block.position.set(t.x, t.y, t.zPos);
    block.castShadow = true;
    block.receiveShadow = true;
    g.add(block);
  }

  // Mark spectator slots for later model placement
  const crowdPositions = [];

  for(const t of tiers){
    const yTop = t.y + t.h * 0.5 + 0.08;
    const zMin = -t.z * 0.5 + 1.2;
    const zMax = t.z * 0.5 - 1.2;
    for(let z = zMin; z <= zMax; z += 1.4){
      crowdPositions.push({x: -t.x - t.w * 0.15, y: yTop, z, dir: 1});
      crowdPositions.push({x: -t.x + t.w * 0.15, y: yTop, z, dir: 1});
      crowdPositions.push({x: t.x - t.w * 0.15, y: yTop, z, dir: -1});
      crowdPositions.push({x: t.x + t.w * 0.15, y: yTop, z, dir: -1});
    }
  }

  for(const t of endTiers){
    const yTop = t.y + t.h * 0.5 + 0.08;
    const xMin = -t.w * 0.5 + 1.2;
    const xMax = t.w * 0.5 - 1.2;
    for(let x = xMin; x <= xMax; x += 1.5){
      crowdPositions.push({x, y: yTop, z: t.zPos - t.z * 0.15, dir: t.zPos > 0 ? -1 : 1});
      crowdPositions.push({x, y: yTop, z: t.zPos + t.z * 0.15, dir: t.zPos > 0 ? -1 : 1});
    }
  }

  g.userData.crowdSpots = crowdPositions;

  // Referee chair / ref box
  const refGroup = new THREE.Group();
  const refX = -16.8;
  const refZ = 0;
  const refBaseMat = new THREE.MeshStandardMaterial({color:0x30475d, roughness:0.7, metalness:0.15});
  const refSeatMat = new THREE.MeshStandardMaterial({color:0x2f6db4, roughness:0.65, metalness:0.08});

  const base = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.35, 2.1), refBaseMat);
  base.position.set(refX, 0.18, refZ);
  base.castShadow = true;
  base.receiveShadow = true;
  refGroup.add(base);

  const railGeo = new THREE.BoxGeometry(0.16, 2.6, 0.16);
  const railFL = new THREE.Mesh(railGeo, refBaseMat);
  const railFR = railFL.clone();
  const railBL = railFL.clone();
  const railBR = railFL.clone();
  railFL.position.set(refX - 1.05, 1.5, refZ - 0.8);
  railFR.position.set(refX - 1.05, 1.5, refZ + 0.8);
  railBL.position.set(refX + 1.05, 1.5, refZ - 0.8);
  railBR.position.set(refX + 1.05, 1.5, refZ + 0.8);
  refGroup.add(railFL, railFR, railBL, railBR);

  const platform = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.18, 1.9), refBaseMat);
  platform.position.set(refX, 2.76, refZ);
  platform.castShadow = true;
  platform.receiveShadow = true;
  refGroup.add(platform);

  const seat = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.18, 0.8), refSeatMat);
  seat.position.set(refX + 0.2, 3.02, refZ);
  seat.castShadow = true;
  refGroup.add(seat);

  const backRest = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.15), refSeatMat);
  backRest.position.set(refX - 0.25, 3.4, refZ);
  backRest.castShadow = true;
  refGroup.add(backRest);

  g.userData.refereeSpot = new THREE.Vector3(refX + 0.15, 2.86, refZ);
  g.userData.refereeFacing = 0;
  g.add(refGroup);

  // Stadium floodlights
  const poleMat = new THREE.MeshStandardMaterial({color:0xd9dde1, roughness:0.35, metalness:0.35});
  const lampMat = new THREE.MeshStandardMaterial({color:0xf8f8ff, emissive:0xd7e2ff, emissiveIntensity:0.35});
  const poles = [
    [-23.5, -36], [23.5, -36], [-23.5, 36], [23.5, 36]
  ];
  for(const [x, z] of poles){
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.26, 18, 14), poleMat);
    pole.position.set(x, 9, z);
    pole.castShadow = true;
    g.add(pole);

    const lampRig = new THREE.Mesh(new THREE.BoxGeometry(3.2, 1, 1.1), lampMat);
    lampRig.position.set(x + (x < 0 ? 1.8 : -1.8), 17.6, z + (z < 0 ? 1.3 : -1.3));
    lampRig.castShadow = true;
    g.add(lampRig);

    const flood = new THREE.SpotLight(0xf6fbff, 0.8, 160, Math.PI / 6, 0.35, 1.3);
    flood.position.set(x + (x < 0 ? 1.8 : -1.8), 17.1, z + (z < 0 ? 1.3 : -1.3));
    flood.target.position.set(0, 0, 0);
    flood.castShadow = false;
    g.add(flood, flood.target);
  }

  return g;
}

const stadium = createStadium();
scene.add(stadium);

function populateStadiumPeople(stadiumRoot){
  const crowdSpots = stadiumRoot.userData.crowdSpots || [];
  const refSpot = stadiumRoot.userData.refereeSpot || new THREE.Vector3(-16.8, 2.86, 0);
  const crowdGeo = new THREE.CapsuleGeometry(0.2, 0.72, 4, 10);
  const crowdMat = new THREE.MeshStandardMaterial({color:0xc2c7cd, roughness:0.82, metalness:0.02});
  const crowd = new THREE.InstancedMesh(crowdGeo, crowdMat, crowdSpots.length);
  const d = new THREE.Object3D();
  for(let i = 0; i < crowdSpots.length; i++){
    const s = crowdSpots[i];
    d.position.set(s.x, s.y + 0.72, s.z);
    d.rotation.y = Math.atan2(-s.x, -s.z) + (Math.random() - 0.5) * 0.2;
    d.scale.setScalar(0.95 + Math.random() * 0.2);
    d.updateMatrix();
    crowd.setMatrixAt(i, d.matrix);
  }
  crowd.instanceMatrix.needsUpdate = true;
  crowd.castShadow = false;
  crowd.receiveShadow = true;
  stadiumRoot.add(crowd);

  // Procedural referee in the chair
  const refGroup = new THREE.Group();
  const torso = new THREE.Mesh(
    new THREE.CylinderGeometry(0.18, 0.22, 0.62, 12),
    new THREE.MeshStandardMaterial({color:0x2f3842, roughness:0.7, metalness:0.03})
  );
  torso.position.y = 0.98;
  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.16, 14, 12),
    new THREE.MeshStandardMaterial({color:0xf0c9a4, roughness:0.74, metalness:0})
  );
  head.position.y = 1.42;
  const legL = new THREE.Mesh(
    new THREE.CylinderGeometry(0.07, 0.07, 0.5, 10),
    new THREE.MeshStandardMaterial({color:0x2a3038, roughness:0.75, metalness:0.02})
  );
  const legR = legL.clone();
  legL.position.set(-0.09, 0.55, 0.03);
  legR.position.set(0.09, 0.55, 0.03);
  refGroup.add(torso, head, legL, legR);
  refGroup.position.copy(refSpot);
  refGroup.lookAt(0, refSpot.y, 0);
  refGroup.traverse((o)=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; }});
  stadiumRoot.add(refGroup);
}

populateStadiumPeople(stadium);

const lineMat = new THREE.LineBasicMaterial({color:0xffffff});
const drawLine=(a,b)=>{
 const g=new THREE.BufferGeometry().setFromPoints([
  new THREE.Vector3(...a),new THREE.Vector3(...b)
 ]);
 scene.add(new THREE.Line(g,lineMat));
};

drawLine([-COURT_HALF_W,.01,BASELINE],[COURT_HALF_W,.01,BASELINE]);
drawLine([-COURT_HALF_W,.01,-BASELINE],[COURT_HALF_W,.01,-BASELINE]);
drawLine([-COURT_HALF_W,.01,-BASELINE],[-COURT_HALF_W,.01,BASELINE]);
drawLine([COURT_HALF_W,.01,-BASELINE],[COURT_HALF_W,.01,BASELINE]);

drawLine([-SINGLES_HALF_W,.01,-BASELINE],[-SINGLES_HALF_W,.01,BASELINE]);
drawLine([SINGLES_HALF_W,.01,-BASELINE],[SINGLES_HALF_W,.01,BASELINE]);

drawLine([-SINGLES_HALF_W,.01,SERVICE],[SINGLES_HALF_W,.01,SERVICE]);
drawLine([-SINGLES_HALF_W,.01,-SERVICE],[SINGLES_HALF_W,.01,-SERVICE]);

drawLine([0,.01,0],[0,.01,SERVICE]);
drawLine([0,.01,0],[0,.01,-SERVICE]);

//////////////////////////////////////////////////
// NET
//////////////////////////////////////////////////

const NET_WIDTH = COURT_HALF_W * 2;
const NET_POST_H = 1.5;
const NET_CENTER_H = 1.4;

function netHeightAtX(x){
  const clampedX = THREE.MathUtils.clamp(x, -NET_WIDTH * 0.5, NET_WIDTH * 0.5);
  const t = Math.abs(clampedX) / (NET_WIDTH * 0.5);
  return THREE.MathUtils.lerp(NET_CENTER_H, NET_POST_H, t * t);
}

function createNet(){
  const g = new THREE.Group();

  const clothGeo = new THREE.PlaneGeometry(NET_WIDTH, NET_POST_H, 64, 8);
  const p = clothGeo.attributes.position;
  for(let i = 0; i < p.count; i++){
    const x = p.getX(i);
    const y = p.getY(i);
    const v = (y + NET_POST_H * 0.5) / NET_POST_H; // 0 bottom, 1 top
    p.setY(i, v * netHeightAtX(x));
  }
  p.needsUpdate = true;
  clothGeo.computeVertexNormals();

  const cloth = new THREE.Mesh(
    clothGeo,
    new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.18,
      side: THREE.DoubleSide,
      depthWrite: false,
      roughness: 0.9,
      metalness: 0
    })
  );
  cloth.castShadow = true;
  g.add(cloth);

  // Subtle string lines
  const wire = new THREE.LineSegments(
    new THREE.WireframeGeometry(clothGeo),
    new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.28,
      depthWrite: false
    })
  );
  g.add(wire);

  // Top tape line
  const tapePts = [];
  for(let x = -NET_WIDTH * 0.5; x <= NET_WIDTH * 0.5 + 1e-6; x += 0.4){
    tapePts.push(new THREE.Vector3(x, netHeightAtX(x) + 0.03, 0));
  }
  const tape = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(tapePts),
    new THREE.LineBasicMaterial({color:0xf3f3f3, transparent:true, opacity:0.9})
  );
  g.add(tape);

  // Net posts
  const postMat = new THREE.MeshStandardMaterial({color:0xe6e6e6, roughness:0.6, metalness:0.1});
  const leftPost = new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.09,NET_POST_H + 0.25,12), postMat);
  const rightPost = leftPost.clone();
  leftPost.position.set(-NET_WIDTH * 0.5 - 0.15, (NET_POST_H + 0.25) * 0.5, 0);
  rightPost.position.set(NET_WIDTH * 0.5 + 0.15, (NET_POST_H + 0.25) * 0.5, 0);
  leftPost.castShadow = true;
  rightPost.castShadow = true;
  g.add(leftPost);
  g.add(rightPost);

  return g;
}

scene.add(createNet());

//////////////////////////////////////////////////
// PLAYER MODEL
//////////////////////////////////////////////////

function createRacketMesh(){
  const racket = new THREE.Group();

  const handleMat = new THREE.MeshStandardMaterial({color:0x2f3136, roughness:0.55, metalness:0.15});
  const frameMat = new THREE.MeshStandardMaterial({color:0x2d333a, roughness:0.35, metalness:0.45});
  const stringsMat = new THREE.MeshStandardMaterial({
  color:0xffffff,
  roughness:0.92,
  metalness:0,
  transparent:true,
  opacity:0.9
 });

 const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.035, 0.42, 10), handleMat);
 handle.position.y = -0.32;
 racket.add(handle);

 const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.045, 10), handleMat);
 cap.position.y = -0.55;
 racket.add(cap);

 const throat = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.17, 0.028), frameMat);
 throat.position.y = -0.09;
 racket.add(throat);

 const head = new THREE.Mesh(new THREE.TorusGeometry(0.24, 0.025, 12, 56), frameMat);
 head.position.y = 0.21;
 racket.add(head);

 const strings = new THREE.Mesh(new THREE.PlaneGeometry(0.36, 0.5, 8, 12), stringsMat);
 strings.position.y = 0.21;
 strings.rotation.y = Math.PI;
 racket.add(strings);

 const edge = new THREE.Mesh(new THREE.TorusGeometry(0.24, 0.006, 8, 56), stringsMat);
 edge.position.y = 0.21;
 edge.scale.set(0.8, 1.0, 1.0);
 racket.add(edge);

 racket.traverse((obj)=>{
  if(obj.isMesh){
   obj.castShadow = true;
   obj.receiveShadow = true;
  }
 });

  return racket;
}

function attachRacketToCharacter(char){
 if(char.racketPivot && char.racketPivot.parent){
  char.racketPivot.parent.remove(char.racketPivot);
 }

 const pivot = new THREE.Group();
 const racket = createRacketMesh();
 // Hand anchor should sit at the grip (not frame) and with correct up/down orientation.
 racket.position.y = 0.5;
 racket.rotation.z = Math.PI;
 racket.scale.setScalar(1.16);
 pivot.add(racket);
 char.racketPivot = pivot;

 const anchor = char.rightArm || char;

 if(char.rightArm){
  pivot.position.set(0.16, -0.74, 0.08);
  pivot.rotation.set(0.2, -0.1, Math.PI * 0.8);
 } else {
  pivot.position.set(0.5, 1.1, 0.0);
  pivot.rotation.set(0.32, 0.0, Math.PI * 0.85);
 }

 pivot.userData.baseRotation = pivot.rotation.clone();
 anchor.add(pivot);
}

function createPlayer(color,pants){
 const g=new THREE.Group();
 const proxy = new THREE.Group();
 g.add(proxy);
 const skinMat = new THREE.MeshStandardMaterial({color:0xffd2aa, roughness:0.72, metalness:0});
 const clothMat = new THREE.MeshStandardMaterial({color, roughness:0.66, metalness:0.03});
 const pantsMat = new THREE.MeshStandardMaterial({color:pants, roughness:0.75, metalness:0.02});

 const torso=new THREE.Mesh(
  new THREE.CapsuleGeometry(.48,1.2,8,16),
  clothMat
 );
 torso.position.y=1.18;
 torso.castShadow = true;
 proxy.add(torso);

 const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.11,0.12,0.2,10), skinMat);
 neck.position.y = 2.02;
 neck.castShadow = true;
 proxy.add(neck);

 const head=new THREE.Mesh(
  new THREE.SphereGeometry(.42, 20, 16),
  skinMat
 );
 head.position.y=2.42;
 head.castShadow = true;
 proxy.add(head);

 const shoulderGeo = new THREE.SphereGeometry(0.15, 12, 10);
 const armGeo=new THREE.CylinderGeometry(.14,.14,1.45,12);
 const legGeo=new THREE.CylinderGeometry(.25,.25,2);

 const lShoulder = new THREE.Mesh(shoulderGeo, clothMat);
 const rShoulder = lShoulder.clone();
 lShoulder.position.set(-0.62,1.78,0);
 rShoulder.position.set(0.62,1.78,0);
 lShoulder.castShadow = true;
 rShoulder.castShadow = true;
 proxy.add(lShoulder, rShoulder);

 const la=new THREE.Mesh(armGeo,clothMat);
 la.position.set(-.74,1.18,0);
 la.castShadow = true;
 proxy.add(la);

 const ra=new THREE.Mesh(armGeo,clothMat);
 ra.position.set(.74,1.18,0);
 ra.castShadow = true;
 proxy.add(ra);

 const lHand = new THREE.Mesh(new THREE.SphereGeometry(0.13, 12, 10), skinMat);
 const rHand = lHand.clone();
 lHand.position.set(-0.74, 0.5, 0);
 rHand.position.set(0.74, 0.5, 0);
 lHand.castShadow = true;
 rHand.castShadow = true;
 proxy.add(lHand, rHand);

 const ll=new THREE.Mesh(legGeo,pantsMat);
 ll.position.set(-.35,-0.98,0);
 ll.castShadow = true;
 proxy.add(ll);

 const rl=new THREE.Mesh(legGeo,pantsMat);
 rl.position.set(.35,-0.98,0);
 rl.castShadow = true;
 proxy.add(rl);

 const shoeMat = new THREE.MeshStandardMaterial({color:0xe6e7ea, roughness:0.45, metalness:0.06});
 const lShoe = new THREE.Mesh(new THREE.BoxGeometry(0.33,0.13,0.62), shoeMat);
 const rShoe = lShoe.clone();
 lShoe.position.set(-0.35,-2.02,0.11);
 rShoe.position.set(0.35,-2.02,0.11);
 lShoe.castShadow = true;
 rShoe.castShadow = true;
 proxy.add(lShoe, rShoe);

 g.leftArm=la; g.rightArm=ra;
 g.leftLeg=ll; g.rightLeg=rl;
 g.torso=torso; g.head=head;
 g.proxy=proxy;
 g.animState="idle";
 g.animTime=0;
 g.swingValue=0;
 g.swingTarget=0;
 g.hitTimer=0;
 g.hitDuration=0.24;
 g.hitPower=0;
 g.reachX=0;
 g.reachY=0;
 g.jumpAmount=0;
 g.leanAmount=0;
 g.targetReachX=0;
 g.targetReachY=0;
 g.targetJump=0;
 g.targetLean=0;
 g.racketPivot=null;
 g.racketSnap=0;

 return g;
}

const player=createPlayer(0xffaa00,0x2244ff);
player.position.set(0,1.35,-22);
scene.add(player);
attachRacketToCharacter(player);

const ai=createPlayer(0x00aaff,0xff3344);
ai.position.set(0,1.35,22);
ai.rotation.y=Math.PI;
scene.add(ai);
attachRacketToCharacter(ai);

//////////////////////////////////////////////////
// BALL PHYSICS
//////////////////////////////////////////////////

const ball = new THREE.Mesh(
 new THREE.SphereGeometry(.24, 24, 24),
 new THREE.MeshPhysicalMaterial({
  color:0xd7e43a,
  roughness:0.86,
  metalness:0,
  clearcoat:0.05,
  sheen:0.2,
  sheenColor:new THREE.Color(0xf3f59a)
 })
);
ball.castShadow = true;
scene.add(ball);

// Tennis ball seam details
const seamMat = new THREE.MeshBasicMaterial({color:0xf8f8ee});
const seamA = new THREE.Mesh(new THREE.TorusGeometry(0.165, 0.012, 8, 48), seamMat);
const seamB = seamA.clone();
seamA.rotation.set(Math.PI * 0.5, Math.PI * 0.26, 0);
seamB.rotation.set(Math.PI * 0.5, -Math.PI * 0.26, Math.PI);
ball.add(seamA);
ball.add(seamB);

const ballVel=new THREE.Vector3();
const BALL_RADIUS = 0.24;

const GRAVITY=28;
const DRAG=.16;
const BOUNCE=.78;
const FRICTION=.88;
let lastHitter = "ai";
let bouncePlayerSide = 0;
let bounceAiSide = 0;
let pendingPointWinner = null;
let pendingPointReason = "";
let pendingPointTimer = 0;
let awaitingNextPointStart = false;
const POINT_RESET_DELAY = 1.05;
const rallyCallout = document.getElementById("rallyCallout");

function resetRallyState(){
 bouncePlayerSide = 0;
 bounceAiSide = 0;
}

function showRallyCallout(message){
 rallyCallout.textContent = message;
 rallyCallout.style.opacity = "1";
}

function hideRallyCallout(){
 rallyCallout.style.opacity = "0";
}

function scoreWord(v){
 if(v === "0") return "love";
 if(v === "15") return "fifteen";
 if(v === "30") return "thirty";
 if(v === "40") return "forty";
 if(v === "AD") return "advantage";
 return `${v}`;
}

function pointScoreForSpeech(){
 const youPoint = pointText(tennisScore.pointsYou, tennisScore.pointsAi);
 const aiPoint = pointText(tennisScore.pointsAi, tennisScore.pointsYou);
 if(tennisScore.pointsYou >= 3 && tennisScore.pointsAi >= 3){
  if(tennisScore.pointsYou === tennisScore.pointsAi) return "deuce";
  if(tennisScore.pointsYou > tennisScore.pointsAi) return `advantage ${PLAYER_NAME}`;
  return `advantage ${AI_NAME}`;
 }
 return `${scoreWord(youPoint)} ${allCapName(PLAYER_NAME)}, ${scoreWord(aiPoint)} ${allCapName(AI_NAME)}`;
}

function allCapName(name){
 return name.replace(/\s+/g, " ").trim();
}

function scoreSummaryForSpeech(){
 return `${pointScoreForSpeech()}`;
}

let announcerVoice = null;
if("speechSynthesis" in window){
 const pickVoice = () => {
  const voices = window.speechSynthesis.getVoices();
  announcerVoice = voices.find(v => /^en(-|_)/i.test(v.lang)) || voices[0] || null;
 };
 pickVoice();
 window.speechSynthesis.onvoiceschanged = pickVoice;
}

function speakLines(lines, onDone){
 if(!("speechSynthesis" in window)){
  onDone?.();
  return;
 }
 const synth = window.speechSynthesis;
 const queue = lines.filter(Boolean);
 if(queue.length === 0){
  onDone?.();
  return;
 }

 synth.cancel();
 let idx = 0;
 const speakNext = () => {
  if(idx >= queue.length){
   onDone?.();
   return;
  }
  const utter = new SpeechSynthesisUtterance(queue[idx++]);
  if(announcerVoice) utter.voice = announcerVoice;
  utter.rate = 2.7;
  utter.pitch = 0.2;
  utter.volume = 3.0;
  utter.onend = speakNext;
  utter.onerror = speakNext;
  synth.speak(utter);
 };
 speakNext();
}

function startNextPointAfterAnnouncement(pointResultLine = ""){
 if(tennisScore.matchWinner) return;
 awaitingNextPointStart = true;
 const lines = [];
 if(pointResultLine) lines.push(pointResultLine);
 lines.push(`Score: ${scoreSummaryForSpeech()}.`);

 let done = false;
 const finish = () => {
  if(done || tennisScore.matchWinner) return;
  done = true;
  awaitingNextPointStart = false;
  serveFromAI();
  lastHitter = "ai";
  resetRallyState();
 };

 speakLines(lines, finish);
 if(!("speechSynthesis" in window)){
  finish();
 } else {
  setTimeout(finish, 4600);
 }
}

function pointTo(winner, reason = "Point"){
 if(tennisScore.matchWinner || pendingPointWinner) return;
 pendingPointWinner = winner;
 pendingPointReason = reason;
 pendingPointTimer = POINT_RESET_DELAY;
 const winnerLabel = winner === "you" ? PLAYER_NAME : AI_NAME;
 showRallyCallout(`${reason} - ${winnerLabel} wins point`);
 ballVel.set(0, 0, 0);
 playerVel.set(0, 0, 0);
 aiVel.set(0, 0, 0);
 shotCharging = false;
 shotCharge = 0;
 shotQueueTimer = 0;
 queuedShotPower = 0;
 powerFill.style.width = "0%";
 powerHud.style.opacity = "0";
}

function resolvePendingPoint(){
 if(!pendingPointWinner) return;
 const winner = pendingPointWinner;
 const reason = pendingPointReason || "Point";
  pendingPointWinner = null;
 pendingPointReason = "";
 pendingPointTimer = 0;
 awardPoint(winner);
 hideRallyCallout();
 if(!tennisScore.matchWinner){
  const winnerLabel = winner === "you" ? PLAYER_NAME : AI_NAME;
  startNextPointAfterAnnouncement(`${winnerLabel} point. ${reason}.`);
 } else {
  showRallyCallout(`${tennisScore.matchWinner} wins match`);
  speakLines([`${tennisScore.matchWinner} wins the match.`]);
 }
}

//////////////////////////////////////////////////
// SERVE
//////////////////////////////////////////////////

function serveFromAI(){
 ball.position.set(
   THREE.MathUtils.randFloat(-4,4),
   2.6,
   23
 );

 // Aim into service box
 const target=new THREE.Vector3(
   THREE.MathUtils.randFloat(-6,6),
   0,
   -8
 );

 const dir=target.clone().sub(ball.position);

 ballVel.copy(dir.multiplyScalar(.95));
 ballVel.y=14;
 lastHitter = "ai";
 resetRallyState();
}

startNextPointAfterAnnouncement("Next point.");

//////////////////////////////////////////////////
// ANIMATION
//////////////////////////////////////////////////

function animateRun(char,speed,dt){
 const moveSpeed = Math.abs(speed);
 const move = THREE.MathUtils.clamp(moveSpeed / 22, 0, 1);
 const state = moveSpeed < 3 ? "idle" : (moveSpeed < 12 ? "run" : "sprint");
 char.animState = state;
 const cadence = state === "idle" ? 1.8 : (state === "run" ? 5.5 : 8.8);
 char.animTime += dt * cadence;
 const s = Math.sin(char.animTime);
 const c = Math.cos(char.animTime);

 // Smooth racket swing blend back to run cycle
 char.swingValue = THREE.MathUtils.lerp(char.swingValue, char.swingTarget, dt * 18);
 char.swingTarget = THREE.MathUtils.lerp(char.swingTarget, 0, dt * 8);

 const legAmp = THREE.MathUtils.lerp(0.08, 0.62, move);
 const armAmp = THREE.MathUtils.lerp(0.06, 0.48, move);
 const torsoBob = THREE.MathUtils.lerp(0.015, 0.12, move);
 const stride = THREE.MathUtils.lerp(0.12, 1.0, move);
 char.racketSnap = THREE.MathUtils.lerp(char.racketSnap, 0, dt * 10);
 char.reachX = THREE.MathUtils.lerp(char.reachX, char.targetReachX, dt * 8.5);
 char.reachY = THREE.MathUtils.lerp(char.reachY, char.targetReachY, dt * 8.5);
 char.jumpAmount = THREE.MathUtils.lerp(char.jumpAmount, char.targetJump, dt * 9.5);
 char.leanAmount = THREE.MathUtils.lerp(char.leanAmount, char.targetLean, dt * 7.5);
 if(char.hitTimer > 0) char.hitTimer = Math.max(0, char.hitTimer - dt);
 const hitProgress = char.hitDuration > 0 ? 1 - (char.hitTimer / char.hitDuration) : 1;
 const hitArc = char.hitTimer > 0
  ? Math.sin(hitProgress * Math.PI) * THREE.MathUtils.clamp(char.hitPower * 0.65, 0.35, 1.1)
  : 0;
 if(char.racketPivot && char.racketPivot.userData.baseRotation){
  const base = char.racketPivot.userData.baseRotation;
  char.racketPivot.rotation.set(base.x, base.y, base.z);
  char.racketPivot.rotation.x += hitArc * 0.82 + char.racketSnap * 0.52 + stride * 0.08;
  char.racketPivot.rotation.y += char.reachX * 0.2 + Math.sin(char.animTime * 0.7) * 0.05 * move;
  char.racketPivot.rotation.z += char.leanAmount * 0.16 - Math.sin(char.animTime) * 0.04 * move;
 }

 const stepL = Math.max(0, -s) * 0.14 * stride;
 const stepR = Math.max(0, s) * 0.14 * stride;
 const torsoTwist = s * 0.14 * stride - hitArc * 0.08;
 const shoulderCounter = -torsoTwist * 0.75;

 char.leftLeg.rotation.x = s * legAmp - char.jumpAmount * 0.24;
 char.rightLeg.rotation.x = -s * legAmp - char.jumpAmount * 0.24;
 char.leftLeg.rotation.z = -0.05 * stride + char.leanAmount * 0.04;
 char.rightLeg.rotation.z = 0.05 * stride + char.leanAmount * 0.04;

 char.leftArm.rotation.x = -s * armAmp + hitArc * 0.24 + char.reachY * 0.22;
 char.rightArm.rotation.x = s * armAmp - char.swingValue - hitArc * 0.52 - char.reachY * 0.4;
 char.leftArm.rotation.z = shoulderCounter * 0.42 + char.reachX * 0.06;
 char.rightArm.rotation.z = -char.reachX * 0.35 + shoulderCounter * 0.35;

 char.torso.rotation.y = torsoTwist + char.reachX * 0.12;
 char.torso.rotation.x = -char.reachY * 0.05 - char.jumpAmount * 0.06;
 char.torso.rotation.z = -hitArc * 0.18 - char.leanAmount * 0.26;
 char.head.rotation.y = hitArc * 0.08 + char.reachX * 0.09 - torsoTwist * 0.45;
 char.head.rotation.x = -char.jumpAmount * 0.04 + Math.abs(c) * 0.02 * move;

 char.torso.position.y = 1 + Math.abs(c) * torsoBob + char.jumpAmount * 0.38;
 char.head.position.y = 2.6 + Math.abs(c) * torsoBob * 0.45 + char.jumpAmount * 0.13;
 char.leftLeg.position.y = -0.98 + stepL;
 char.rightLeg.position.y = -0.98 + stepR;
}

function swingRacket(char,amount){
 char.swingTarget = Math.max(char.swingTarget, amount);
 char.hitPower = Math.max(char.hitPower, amount);
 char.hitTimer = char.hitDuration;
 char.racketSnap = Math.max(char.racketSnap, amount * 0.8);
}

//////////////////////////////////////////////////
// PLAYER INPUT + MOVEMENT
//////////////////////////////////////////////////

const keys = {ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, Shift:false};
let shootKeyDown = false;
const powerHud = document.getElementById("powerHud");
const powerFill = document.getElementById("powerFill");

let shotCharge = 0;
let shotCharging = false;
let shootWasDown = false;
let queuedShotPower = 0;
let shotQueueTimer = 0;
const SHOT_CHARGE_TIME = 1.15;
const SHOT_QUEUE_WINDOW = 0.28;

document.addEventListener("keydown",(e)=>{
 if(e.code === "Space") shootKeyDown = true;
 if(e.key in keys) keys[e.key] = true;
});
document.addEventListener("keyup",(e)=>{
 if(e.code === "Space") shootKeyDown = false;
 if(e.key in keys) keys[e.key] = false;
});

let gamepadIndex = null;
window.addEventListener("gamepadconnected",(e)=>{
 gamepadIndex = e.gamepad.index;
});
window.addEventListener("gamepaddisconnected",(e)=>{
 if(gamepadIndex === e.gamepad.index) gamepadIndex = null;
});

function getActiveGamepad(){
 const pads = navigator.getGamepads ? navigator.getGamepads() : [];
 if(gamepadIndex !== null && pads[gamepadIndex] && pads[gamepadIndex].connected){
  return pads[gamepadIndex];
 }
 for(const gp of pads){
  if(gp && gp.connected){
   gamepadIndex = gp.index;
   return gp;
  }
 }
 return null;
}

function getMoveInput(){
 const input = new THREE.Vector2(0,0);

 // Keyboard fallback
 if(keys.ArrowLeft) input.x -= 1;
 if(keys.ArrowRight) input.x += 1;
 if(keys.ArrowUp) input.y += 1;
 if(keys.ArrowDown) input.y -= 1;

 // Xbox left stick
 const gp = getActiveGamepad();
 if(gp){
  const deadzone = 0.14;
  const stick = new THREE.Vector2(gp.axes[0] || 0, -(gp.axes[1] || 0));
  const mag = stick.length();
  if(mag > deadzone){
   const scaled = Math.min((mag - deadzone) / (1 - deadzone), 1);
   stick.normalize().multiplyScalar(scaled);
   input.add(stick);
  }
 }

 if(input.lengthSq() > 1) input.normalize();
 return input;
}

function getAimInput(){
 const gp = getActiveGamepad();
 if(!gp) return new THREE.Vector2(0,1);
 const deadzone = 0.2;
 // Same reference as move stick: raw X, inverted Y.
 const aim = new THREE.Vector2(gp.axes[2] || 0, -(gp.axes[3] || 0));
 const mag = aim.length();
 if(mag <= deadzone) return new THREE.Vector2(0,1);
 const scaled = Math.min((mag - deadzone) / (1 - deadzone), 1);
 return aim.normalize().multiplyScalar(scaled);
}

function isSprinting(){
 const gp = getActiveGamepad();
 const gpSprint = gp && ((gp.buttons[10] && gp.buttons[10].pressed) || (gp.buttons[5] && gp.buttons[5].pressed));
 return !!(keys.Shift || gpSprint);
}

function isShootPressed(){
 const gp = getActiveGamepad();
 const rt = gp && gp.buttons[7] ? (gp.buttons[7].pressed || (gp.buttons[7].value || 0) > 0.2) : false;
 return !!(shootKeyDown || rt);
}

function updateShotCharge(dt){
 const pressed = isShootPressed();
 if(pressed){
  shotCharging = true;
  shotCharge = Math.min(1, shotCharge + dt / SHOT_CHARGE_TIME);
 } else if(shootWasDown && shotCharging){
  queuedShotPower = Math.max(0.08, shotCharge);
  shotQueueTimer = SHOT_QUEUE_WINDOW;
  shotCharge = 0;
  shotCharging = false;
 }
 shootWasDown = pressed;

 if(shotQueueTimer > 0){
  shotQueueTimer = Math.max(0, shotQueueTimer - dt);
 }

 powerHud.style.opacity = shotCharging ? "1" : "0";
 powerFill.style.width = `${Math.round(shotCharge * 100)}%`;
}

const playerVel = new THREE.Vector3();
const BASE_MOVE_SPEED = 11.5;
const SPRINT_MULT = 1.35;
const PLAYER_BODY_HIT_RADIUS = 6.8;
const PLAYER_RACKET_HIT_RADIUS = 5.9;
const PLAYER_HIT_MAX_Y = 6.5;
const aiVel = new THREE.Vector3();
const AI_BASE_Y = 1.35;
const AI_MAX_SPEED = 13.5;
const AI_REACTION = 7.2;
const AI_HIT_RADIUS = 1.8;
let aiHitCooldown = 0;

function updatePlayer(dt){
 const input = getMoveInput();
 const moveSpeed = BASE_MOVE_SPEED * (isSprinting() ? SPRINT_MULT : 1);
 playerVel.set(-input.x * moveSpeed, 0, input.y * moveSpeed);
 player.position.addScaledVector(playerVel, dt);

 // Rotate player towards movement direction
 if(input.lengthSq() > 0.0001){
  const targetYaw = Math.atan2(-input.x, input.y);
  const deltaYaw = ((targetYaw - player.rotation.y + Math.PI) % (Math.PI * 2)) - Math.PI;
  player.rotation.y += deltaYaw * Math.min(1, dt * 14);
 }

 // Keep player on near side of court
 player.position.x = THREE.MathUtils.clamp(player.position.x, -COURT_HALF_W, COURT_HALF_W);
 player.position.z = THREE.MathUtils.clamp(player.position.z, -25, -5);
}

function updateAI(dt){
 const target = new THREE.Vector3(0, AI_BASE_Y, 20);

 // Track incoming ball with simple prediction; otherwise recover to good court position.
 if(ballVel.z > 0 && ball.position.z > -2){
  const zGap = Math.max(0, ai.position.z - ball.position.z);
  const t = zGap / Math.max(0.01, ballVel.z);
  const predictedX = ball.position.x + ballVel.x * t;
  const predictedZ = ball.position.z + ballVel.z * t;
  target.x = THREE.MathUtils.clamp(predictedX, -11.8, 11.8);
  target.z = THREE.MathUtils.clamp(predictedZ - 1.1, 8, 23.5);
 } else {
  target.x = THREE.MathUtils.clamp(player.position.x * 0.22, -4.5, 4.5);
  target.z = 20.5;
 }

 const desired = target.clone().sub(ai.position);
 desired.y = 0;
 const dist = desired.length();
 if(dist > 0.01){
  desired.setLength(Math.min(AI_MAX_SPEED, dist * 6.2));
 } else {
  desired.set(0,0,0);
 }

 aiVel.lerp(desired, Math.min(1, dt * AI_REACTION));
 ai.position.addScaledVector(aiVel, dt);
 ai.position.x = THREE.MathUtils.clamp(ai.position.x, -COURT_HALF_W, COURT_HALF_W);
 ai.position.z = THREE.MathUtils.clamp(ai.position.z, 5, 24.2);
 ai.position.y = AI_BASE_Y;

 if(aiVel.lengthSq() > 0.002){
  const targetYaw = Math.atan2(aiVel.x, aiVel.z);
  const deltaYaw = ((targetYaw - ai.rotation.y + Math.PI) % (Math.PI * 2)) - Math.PI;
  ai.rotation.y += deltaYaw * Math.min(1, dt * 9);
 }
}

function getPlayerRacketCenter(){
 const forward = new THREE.Vector3(Math.sin(player.rotation.y), 0, Math.cos(player.rotation.y));
 const right = new THREE.Vector3(Math.cos(player.rotation.y), 0, -Math.sin(player.rotation.y));
 return player.position.clone()
  .addScaledVector(forward, 1.05)
  .addScaledVector(right, 0.72)
  .add(new THREE.Vector3(0, 1.15, 0));
}

function canPlayerHitBall(){
 if(ball.position.y > PLAYER_HIT_MAX_Y) return false;
 const racketCenter = getPlayerRacketCenter();
 const byRacket = ball.position.distanceTo(racketCenter) <= PLAYER_RACKET_HIT_RADIUS;
 const byBody = ball.position.distanceTo(player.position) <= PLAYER_BODY_HIT_RADIUS;
 return byRacket || byBody;
}

function applyNetClearanceAssist(vel, contactPos, margin = 0.35){
 // Only assist shots traveling toward the opposite side of the net.
 const towardOtherSide = (contactPos.z < 0 && vel.z > 0) || (contactPos.z > 0 && vel.z < 0);
 if(!towardOtherSide) return;

 // Base lift floor: closer contact to net needs more lift.
 const zDistToNet = Math.max(0.5, Math.abs(contactPos.z));
 const nearFactor = THREE.MathUtils.clamp(1 - zDistToNet / 18, 0, 1);
 const minLift = THREE.MathUtils.lerp(7.8, 13.6, nearFactor);
 if(vel.y < minLift) vel.y = minLift;

 // Physics-based net-clearance: ensure y(t_net) > net height + margin.
 if(Math.abs(vel.z) > 0.01){
  const tNet = Math.abs(contactPos.z / vel.z);
  if(tNet > 0.01){
   const xAtNet = contactPos.x + vel.x * tNet;
   const requiredYAtNet = netHeightAtX(xAtNet) + BALL_RADIUS + margin;
   const requiredVy = (requiredYAtNet - contactPos.y + 0.5 * GRAVITY * tNet * tNet) / tNet;
   if(vel.y < requiredVy) vel.y = requiredVy;
  }
 }
}

function updateBallReactiveTargets(char, forwardSign){
 const dx = ball.position.x - char.position.x;
 const dz = ball.position.z - char.position.z;
 const distXZ = Math.hypot(dx, dz);
 const inFront = THREE.MathUtils.clamp((forwardSign * dz + 1.2) / 6.5, 0, 1);
 const reachRange = THREE.MathUtils.clamp(1 - distXZ / 8.5, 0, 1);
 const heightFactor = THREE.MathUtils.clamp((ball.position.y - 1.2) / 3.6, 0, 1);
 const lateralFactor = THREE.MathUtils.clamp(dx / 3.8, -1, 1);
 const engage = inFront * reachRange;

 char.targetReachX = lateralFactor * engage;
 char.targetReachY = heightFactor * engage;
 char.targetLean = lateralFactor * engage * 0.8;
 char.targetJump = heightFactor * engage;

 // Trigger an anticipatory swing when ball is close and reachable.
 if(engage > 0.72 && ball.position.y < 3.8 && char.hitTimer <= 0.03){
  swingRacket(char, 0.7 + engage * 0.5);
 }
}

//////////////////////////////////////////////////
// GAME LOOP
//////////////////////////////////////////////////

const clock=new THREE.Clock();

function animate(){
 requestAnimationFrame(animate);
 const dt=clock.getDelta();
 if(pendingPointWinner){
  pendingPointTimer -= dt;
  if(pendingPointTimer <= 0){
   resolvePendingPoint();
  }
  animateRun(player,playerVel.length(),dt);
  animateRun(ai,aiVel.length(),dt);
  renderer.render(scene,camera);
  return;
 }
 if(awaitingNextPointStart){
  animateRun(player,playerVel.length(),dt);
  animateRun(ai,aiVel.length(),dt);
  renderer.render(scene,camera);
  return;
 }
 const prevBallZ = ball.position.z;
 updatePlayer(dt);
 updateShotCharge(dt);
 aiHitCooldown = Math.max(0, aiHitCooldown - dt);

 //////////////////////////////
 // BALL MOTION
 //////////////////////////////

 ballVel.y-=GRAVITY*dt;
 ballVel.multiplyScalar(Math.exp(-DRAG*dt));
 ball.position.addScaledVector(ballVel,dt);

 // Bounce
 if(ball.position.y < BALL_RADIUS){
  ball.position.y = BALL_RADIUS;
  if(ballVel.y<0){
   // Rally rules: in/out and double-bounce on each side.
   // If a side already had one legal bounce this rally phase, the next
   // bounce on that same side is a double-bounce loss even if it drifts out.
   if(ball.position.z < 0 && bouncePlayerSide >= 1){
    pointTo("ai", "Double Bounce");
    return;
   }
   if(ball.position.z >= 0 && bounceAiSide >= 1){
    pointTo("you", "Double Bounce");
    return;
   }

   const inSingles = Math.abs(ball.position.x) <= SINGLES_HALF_W;
   const inLength = Math.abs(ball.position.z) <= BASELINE;
   if(!inSingles || !inLength){
    const reason = !inSingles ? "Sideline Out" : "Baseline Out";
    pointTo(lastHitter === "you" ? "ai" : "you", reason);
    return;
   }

   if(ball.position.z < 0){
    bouncePlayerSide += 1;
    bounceAiSide = 0;
    if(bouncePlayerSide >= 2){
      pointTo("ai", "Double Bounce");
      return;
    }
   } else {
    bounceAiSide += 1;
    bouncePlayerSide = 0;
    if(bounceAiSide >= 2){
      pointTo("you", "Double Bounce");
      return;
    }
   }

   ballVel.y*=-BOUNCE;
   ballVel.x*=FRICTION;
   ballVel.z*=FRICTION;
   if(Math.abs(ballVel.y) < 0.9) ballVel.y = 0;
  }
 }

 updateAI(dt);
 updateBallReactiveTargets(player, 1);
 updateBallReactiveTargets(ai, -1);

 // Net collision (upright net at z=0 across court width)
 const crossedNet = (prevBallZ > 0 && ball.position.z <= 0) || (prevBallZ < 0 && ball.position.z >= 0);
 if(
  crossedNet &&
  Math.abs(ball.position.x) < NET_WIDTH * 0.5 &&
  ball.position.y < netHeightAtX(ball.position.x) + 0.1
 ){
  // Rule requested: net touch is out in rally.
  pointTo(lastHitter === "you" ? "ai" : "you", "Net Touch");
  return;
 }

 //////////////////////////////
 // PLAYER HITS
 //////////////////////////////

 const hitZone=1.2;

 if(
  shotQueueTimer > 0 &&
  canPlayerHitBall()
 ){
  const power = THREE.MathUtils.clamp(queuedShotPower, 0, 1);
  const aim = getAimInput();
  // Map to world like movement controls and keep shots generally forward.
  const shotDir2 = new THREE.Vector2(-aim.x, aim.y);
  shotDir2.x *= 0.32; // much softer side steering
  shotDir2.y = Math.max(0.8, shotDir2.y); // keep shots mostly forward
  // Blend aim toward straight-forward to reduce odd/extreme angles.
  shotDir2.lerp(new THREE.Vector2(0, 1), 0.38);
  shotDir2.normalize();
 const shotDir3 = new THREE.Vector3(shotDir2.x, 0, shotDir2.y).normalize();
 const horizontalSpeed = THREE.MathUtils.lerp(20, 32, power);
 let lift = THREE.MathUtils.lerp(8.8, 13.6, power);
 if(ball.position.y < 1.15) lift += 1.1;

  ballVel.set(
   shotDir3.x * horizontalSpeed,
   lift,
   shotDir3.z * horizontalSpeed
  );
  applyNetClearanceAssist(ballVel, ball.position, 0.4);
  swingRacket(player, THREE.MathUtils.lerp(1.0, 2.0, power));
  lastHitter = "you";
  bouncePlayerSide = 0;
  bounceAiSide = 0;

  shotQueueTimer = 0;
  queuedShotPower = 0;
 }

 if(
  aiHitCooldown <= 0 &&
  ballVel.z > 0 &&
  ball.position.z > 4 &&
  ball.position.distanceTo(ai.position) < AI_HIT_RADIUS &&
  ball.position.y < 2.9
 ){
  // Smart return: target away from player with depth to force errors.
  const side = player.position.x >= 0 ? -1 : 1;
  const targetX = THREE.MathUtils.clamp(
    player.position.x + side * (4.5 + Math.random() * 4.2),
    -10.8,
    10.8
  );
  const targetZ = -THREE.MathUtils.lerp(13.5, 19.5, 0.45 + Math.random() * 0.55);
  const toTarget = new THREE.Vector3(targetX - ball.position.x, 0, targetZ - ball.position.z).normalize();
  // Bias AI to clear net: slightly less flat pace + higher minimum lift.
  // Force AI to always hit at high-medium to full pace.
  const pace = THREE.MathUtils.lerp(26, 33, Math.random());
  let lift = ball.position.y > 1.7
    ? THREE.MathUtils.lerp(8.0, 11.2, Math.random())
    : THREE.MathUtils.lerp(9.6, 13.6, Math.random());
  // Extra margin when contact is low or close to net.
  if(ball.position.y < 1.2) lift += 1.4;
  if(ball.position.z < 9) lift += 1.2;

  ballVel.set(toTarget.x * pace, lift, toTarget.z * pace);
  applyNetClearanceAssist(ballVel, ball.position, 0.62);
  swingRacket(ai, 1.6);
  lastHitter = "ai";
  bouncePlayerSide = 0;
  bounceAiSide = 0;
  aiHitCooldown = 0.2;
 }

 //////////////////////////////
 // SCORE + RESET
 //////////////////////////////

 if(ball.position.z < -26){
  pointTo(lastHitter === "you" ? "ai" : "you", "Baseline Out");
  return;
 }
 if(ball.position.z > 26){
  pointTo(lastHitter === "you" ? "ai" : "you", "Baseline Out");
  return;
 }

 //////////////////////////////

 animateRun(player,playerVel.length(),dt);
 animateRun(ai,aiVel.length(),dt);

 renderer.render(scene,camera);
}

animate();

window.addEventListener("resize",()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
